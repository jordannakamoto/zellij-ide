# Zellij PTY Engine Integration Plan

## Current Architecture Analysis ✅

**Excellent refactored structure:**
- ✅ Clean event loop in `TerminalIDE`
- ✅ Feature registry system for extensibility
- ✅ Proper separation of concerns
- ✅ Command palette integration
- ✅ KeybindingManager system

**What needs PTY integration:**
- ❌ `WindowManager` still has placeholder `TerminalState`
- ❌ No actual terminal processes
- ❌ No PTY data flow
- ❌ GUI renders static help text, not real terminals

## Integration Strategy

### Phase 1: Create Terminal Feature (15 min)
Build terminal management as a feature in the existing system:

```rust
// NEW: src/features/terminal.rs
pub struct TerminalFeature {
    pty_manager: Arc<Mutex<PtyManager>>,
    active_terminals: HashMap<PaneId, TerminalInstance>,
}

struct TerminalInstance {
    terminal_id: u32,
    child_pid: RawFd,
    title: String,
    pty_bus: PtyBus,
    terminal_bytes: TerminalBytes,
}
```

### Phase 2: Refactor WindowManager (20 min)
Replace placeholder terminal with real PTY integration:

```rust
// UPDATE: src/window_manager.rs
pub struct TiledPane {
    id: PaneId,
    geometry: PaneGeom,
    terminal_instance: Option<TerminalInstance>, // Real terminal
    is_focused: bool,
}

// Remove old TerminalState struct entirely
```

### Phase 3: PTY Manager Integration (25 min)
Create PTY management system using zellij components:

```rust
// NEW: src/pty_engine.rs
use zellij_server::pty::{Pty, PtyInstruction};
use zellij_server::thread_bus::{Bus, ThreadSenders};

pub struct PtyManager {
    pty: Pty,
    bus: Bus<PtyInstruction>,
    terminal_counter: u32,
    active_processes: HashMap<u32, JoinHandle<()>>,
}

impl PtyManager {
    pub fn spawn_terminal(&mut self, pane_id: PaneId) -> Result<TerminalInstance>
    pub fn kill_terminal(&mut self, terminal_id: u32) -> Result<()>
    pub fn write_to_terminal(&mut self, terminal_id: u32, bytes: &[u8]) -> Result<()>
    pub fn read_terminal_output(&mut self) -> Vec<(u32, Vec<u8>)>
}
```

### Phase 4: Event Loop Integration (15 min)
Connect PTY events to existing event loop:

```rust
// UPDATE: src/terminal_ide.rs
impl TerminalIDE {
    fn run(&mut self) -> Result<()> {
        while self.running {
            // Existing keyboard/mouse events
            if let Ok(event) = crossterm::event::poll(Duration::from_millis(16)) {
                if event {
                    let event = crossterm::event::read()?;
                    self.handle_event(event)?;
                }
            }

            // NEW: Handle PTY events
            self.handle_pty_events()?;

            // Render UI
            self.render()?;
        }
    }

    fn handle_pty_events(&mut self) -> Result<()> {
        // Read terminal output and update panes
        let terminal_feature = self.get_terminal_feature();
        let updates = terminal_feature.read_all_outputs()?;

        for (terminal_id, bytes) in updates {
            self.window_manager.update_terminal_output(terminal_id, bytes)?;
        }
    }
}
```

### Phase 5: GUI Integration (20 min)
Connect real terminal output to GUI rendering:

```rust
// UPDATE: src/gui_controls.rs
impl GuiControls {
    fn render(&mut self, window_manager: &WindowManager) -> Result<()> {
        self.terminal.draw(|f| {
            // Instead of static help text, render actual terminal content
            render_terminal_panes(f, window_manager);

            // Overlay GUI controls on top
            if self.show_overlay {
                render_overlay_controls(f);
            }
        })?;
    }
}

fn render_terminal_panes(frame: &mut Frame, window_manager: &WindowManager) {
    // Render actual terminal grids from PTY output
    for pane in window_manager.get_visible_panes() {
        if let Some(terminal) = &pane.terminal_instance {
            render_terminal_grid(frame, &terminal.terminal_bytes, pane.geometry);
        }
    }
}
```

## Detailed Implementation

### Step 1: Terminal Feature Implementation

```rust
// src/features/terminal.rs
use crate::features::Feature;
use crate::command_palette::{Command, CommandContext, CommandResult};
use zellij_server::pty::{Pty, PtyInstruction};
use std::sync::{Arc, Mutex};

pub struct TerminalFeature {
    pty_manager: Arc<Mutex<PtyManager>>,
}

impl Feature for TerminalFeature {
    fn name(&self) -> &str { "terminal" }

    fn get_commands(&self) -> Vec<Command> {
        vec![
            Command::new("terminal.new", "New Terminal", "Create a new terminal pane"),
            Command::new("terminal.split_right", "Split Right", "Split pane to the right"),
            Command::new("terminal.split_down", "Split Down", "Split pane downward"),
        ]
    }

    fn execute_command(&self, command_id: &str, context: CommandContext) -> Result<CommandResult> {
        match command_id {
            "terminal.new" => self.create_new_terminal(context),
            "terminal.split_right" => self.split_terminal(Direction::Right, context),
            "terminal.split_down" => self.split_terminal(Direction::Down, context),
            _ => Err(anyhow::anyhow!("Unknown terminal command: {}", command_id))
        }
    }
}
```

### Step 2: PTY Manager Core

```rust
// src/pty_engine.rs
pub struct PtyManager {
    pty: Pty,
    bus: Bus<PtyInstruction>,
    terminals: HashMap<u32, TerminalInstance>,
    next_terminal_id: u32,
}

impl PtyManager {
    pub fn new() -> Result<Self> {
        let bus = Bus::empty();
        let pty = Pty {
            active_panes: HashMap::new(),
            bus: bus.clone(),
            id_to_child_pid: HashMap::new(),
            // ... other zellij pty fields
        };

        Ok(Self {
            pty,
            bus,
            terminals: HashMap::new(),
            next_terminal_id: 1,
        })
    }

    pub fn spawn_terminal(&mut self) -> Result<u32> {
        let terminal_id = self.next_terminal_id;
        self.next_terminal_id += 1;

        // Use zellij's spawn_terminal functionality
        self.bus.send(PtyInstruction::SpawnTerminal(
            None, // terminal_action
            None, // name
            NewPanePlacement::NoPreference,
            false, // start_suppressed
            ClientTabIndexOrPaneId::PaneId(PaneId::new()),
        ))?;

        Ok(terminal_id)
    }
}
```

### Step 3: Window Manager Integration

```rust
// src/window_manager.rs - Updated TiledPane
pub struct TiledPane {
    id: PaneId,
    geometry: PaneGeom,
    terminal_id: Option<u32>,  // Link to PTY system
    is_focused: bool,
    // Remove old TerminalState
}

impl WindowManager {
    pub fn create_terminal_pane(&mut self, pty_manager: &mut PtyManager) -> Result<PaneId> {
        let pane_id = PaneId::new();
        let terminal_id = pty_manager.spawn_terminal()?;

        let pane = TiledPane {
            id: pane_id,
            geometry: self.calculate_new_pane_geometry()?,
            terminal_id: Some(terminal_id),
            is_focused: true,
        };

        self.add_pane(pane)?;
        Ok(pane_id)
    }
}
```

## File Changes Summary

### New Files:
- `src/features/terminal.rs` - Terminal feature implementation
- `src/pty_engine.rs` - PTY management core
- `src/features/mod.rs` - Feature module exports

### Updated Files:
- `src/terminal_ide.rs` - Add PTY event handling to event loop
- `src/window_manager.rs` - Replace TerminalState with real terminal IDs
- `src/gui_controls.rs` - Render real terminal content instead of static text
- `src/features.rs` - Register terminal feature
- `src/main.rs` - Add feature module

### Dependencies:
Already have zellij-server, just need proper imports.

## Testing Plan

1. **Phase 1 Test**: Feature registration works
2. **Phase 2 Test**: Can spawn terminal process
3. **Phase 3 Test**: Can type in terminal and see output
4. **Phase 4 Test**: Multiple terminals work
5. **Phase 5 Test**: Pane switching between terminals works

## Estimated Timeline: ~95 minutes
- Phase 1: 15 min (Terminal Feature)
- Phase 2: 20 min (WindowManager refactor)
- Phase 3: 25 min (PTY Manager)
- Phase 4: 15 min (Event loop integration)
- Phase 5: 20 min (GUI integration)

Ready to start building the PTY engine?